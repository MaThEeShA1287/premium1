<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Audio Remixer</title>
  <link rel="icon" type="image/x-icon" href="primium photo.jpg">
  <style>
        body {
           
            cursor: url('https://cur.cursors-4u.net/cursors/cur-2/cur103.cur'), auto; 
        }
    </style>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--accent:#7c3aed;--muted:#9aa4b2;--glass:rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;color:#e6eef8;background:linear-gradient(180deg,#04050a 0%, #071028 100%);}    
    .app{max-width:1200px;margin:24px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 6px 30px rgba(3,6,15,0.6)}
    header{display:flex;align-items:center;gap:16px}
    header h1{margin:0;font-size:20px}
    .layout{display:grid;grid-template-columns:360px 1fr;gap:16px;margin-top:16px}
    .panel{background:var(--panel);padding:14px;border-radius:10px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
    .controls{display:flex;flex-direction:column;gap:12px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=range]{width:100%}
    .row{display:flex;gap:8px}
    .btn{background:linear-gradient(180deg,var(--accent),#4a1f80);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    canvas#wave{width:100%;height:140px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-radius:8px}
    .effects-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .effect{background:var(--glass);padding:10px;border-radius:8px}
    .small{font-size:13px}
    .tog{display:inline-flex;align-items:center;gap:8px}
    .preset-row{display:flex;gap:8px;flex-wrap:wrap}
    .chip{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:999px;font-size:13px;color:var(--muted);cursor:pointer}
    footer{margin-top:14px;font-size:13px;color:var(--muted)}
    .file-row{display:flex;gap:8px;align-items:center}
    .progress{height:8px;background:#09122a;border-radius:6px;overflow:hidden}
    .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#2dd4bf);width:0%}
    /* responsive */
    @media (max-width:900px){.layout{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div style="width:48px;height:48px;border-radius:10px;background:linear-gradient(180deg,var(--accent),#4a1f80);display:flex;align-items:center;justify-content:center;font-weight:700;color:white">AR</div>
      <div>
        <h1>Audio Remixer by HIRU_OFFICIAL</h1>
        <div class="muted">Web Audio + visual editor â€” upload audio, tweak effects, create loops & export</div>
      </div>
    </header>

    <div class="layout">
      <aside class="panel">
        <div class="controls">
          <div class="file-row">
            <input id="file" type="file" accept="audio/*">
            <button id="loadDemo" class="btn">Load Demo</button>
          </div>
          <div class="muted small">Transport</div>
          <div class="row">
            <button id="play" class="btn">Play</button>
            <button id="stop" class="btn" style="background:#334155">Stop</button>
            <button id="record" class="btn" style="background:#ef4444">Record</button>
          </div>

          <div>
            <label>Volume <span id="volVal" class="muted">1.00</span></label>
            <input id="volume" type="range" min="0" max="2" step="0.01" value="1">
          </div>

          <div>
            <label>Pan <span id="panVal" class="muted">0</span></label>
            <input id="pan" type="range" min="-1" max="1" step="0.01" value="0">
          </div>

          <div>
            <label>Playback Rate / Pitch <span id="rateVal" class="muted">1.00</span></label>
            <input id="playbackRate" type="range" min="0.25" max="2" step="0.01" value="1">
          </div>

          <div>
            <label>BPM (for beat-grid) <span id="bpmVal" class="muted">120</span></label>
            <input id="bpm" type="range" min="40" max="220" step="1" value="120">
          </div>

          <div>
            <label>Loop length (bars)</label>
            <input id="loopBars" type="number" min="1" max="16" value="10000000000000000000000000000000000000000">
          </div>

          <div class="muted small">Quick presets</div>
          <div class="preset-row">
            <div class="chip" data-preset="deep">Deep</div>
            <div class="chip" data-preset="vocal">Vocal</div>
            <div class="chip" data-preset="dub">Dub</div>
            <div class="chip" data-preset="lofi">Lo-Fi</div>
          </div>

          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0">

          <div class="muted small">Record / Export</div>
          <div class="row">
            <button id="exportWav" class="btn" style="background:#06b6d4">Export WAV</button>
            <button id="exportLoop" class="btn" style="background:#10b981">Export Loop</button>
          </div>

        </div>
      </aside>

      <main>
        <div class="panel" style="padding-bottom:16px">
          <canvas id="wave"></canvas>
          <div style="display:flex;gap:10px;margin-top:12px;align-items:center">
            <div style="flex:1">
              <div class="muted">Master Meter</div>
              <div class="progress"><i id="meterBar"></i></div>
            </div>
            <div style="width:260px">
              <div class="muted">Beat Grid / Loop</div>
              <div style="display:flex;gap:8px;margin-top:6px">
                <button id="quantize" class="btn" style="background:#334155">Quantize</button>
                <button id="syncLoop" class="btn">Sync Loop</button>
              </div>
            </div>
          </div>
        </div>

        <div class="panel" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="muted">Effects chain</div>
            <div class="muted small">Drag to reorder (simple UI)</div>
          </div>

          <div style="margin-top:10px" class="effects-grid">
            <div class="effect">
              <div style="font-weight:600">Delay / Echo</div>
              <label>Time <span id="delayTimeVal" class="muted">0.25s</span></label>
              <input id="delayTime" type="range" min="0" max="1.5" step="0.01" value="0.25">
              <label>Feedback <span id="delayFBVal" class="muted">0.35</span></label>
              <input id="delayFB" type="range" min="0" max="0.95" step="0.01" value="0.35">
              <label>Wet <span id="delayWetVal" class="muted">0.4</span></label>
              <input id="delayWet" type="range" min="0" max="1" step="0.01" value="0.4">
            </div>

            <div class="effect">
              <div style="font-weight:600">Filter (Lowpass / Highpass)</div>
              <label>Type</label>
              <select id="filterType"><option value="lowpass">Lowpass</option><option value="highpass">Highpass</option><option value="bandpass">Bandpass</option></select>
              <label>Frequency <span id="filterFreqVal" class="muted">1200Hz</span></label>
              <input id="filterFreq" type="range" min="60" max="18000" step="1" value="1200">
              <label>Q <span id="filterQVal" class="muted">1.0</span></label>
              <input id="filterQ" type="range" min="0.1" max="18" step="0.1" value="1">
            </div>

            <div class="effect">
              <div style="font-weight:600">Flanger</div>
              <label>Rate <span id="flangerRateVal" class="muted">0.25Hz</span></label>
              <input id="flangerRate" type="range" min="0.01" max="5" step="0.01" value="0.25">
              <label>Depth <span id="flangerDepthVal" class="muted">0.003s</span></label>
              <input id="flangerDepth" type="range" min="0.0005" max="0.02" step="0.0001" value="0.003">
            </div>

            <div class="effect">
              <div style="font-weight:600">Phaser</div>
              <label>Rate <span id="phaserRateVal" class="muted">0.4Hz</span></label>
              <input id="phaserRate" type="range" min="0.01" max="5" step="0.01" value="0.4">
              <label>Depth <span id="phaserDepthVal" class="muted">0.8</span></label>
              <input id="phaserDepth" type="range" min="0" max="1" step="0.01" value="0.8">
            </div>

            <div class="effect">
              <div style="font-weight:600">Gate / Tremolo</div>
              <label>Rate <span id="gateRateVal" class="muted">8Hz</span></label>
              <input id="gateRate" type="range" min="0.1" max="30" step="0.1" value="8">
              <label>Depth <span id="gateDepthVal" class="muted">1.0</span></label>
              <input id="gateDepth" type="range" min="0" max="1" step="0.01" value="1">
            </div>

            <div class="effect">
              <div style="font-weight:600">Bit Crusher (DB flip)</div>
              <label>Bits <span id="bitsVal" class="muted">16</span></label>
              <input id="bits" type="range" min="1" max="16" step="1" value="16">
              <label>Norm <span id="normVal" class="muted">1.0</span></label>
              <input id="norm" type="range" min="0" max="1" step="0.01" value="1">
            </div>

          </div>

          <div style="margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <div class="tog"><input id="enableDelay" type="checkbox"> <label for="enableDelay">Delay</label></div>
            <div class="tog"><input id="enableFilter" type="checkbox" checked> <label for="enableFilter">Filter</label></div>
            <div class="tog"><input id="enableFlanger" type="checkbox"> <label for="enableFlanger">Flanger</label></div>
            <div class="tog"><input id="enablePhaser" type="checkbox"> <label for="enablePhaser">Phaser</label></div>
            <div class="tog"><input id="enableGate" type="checkbox"> <label for="enableGate">Gate</label></div>
            <div class="tog"><input id="enableCrush" type="checkbox"> <label for="enableCrush">BitCrusher</label></div>
          </div>

        </div>

        <div class="panel" style="margin-top:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div class="muted">Advanced Tools</div>
            <div class="muted small">Stutter / Roll / Freeze</div>
          </div>
          <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="stutter" class="btn">Stutter (Roll)</button>
            <button id="freeze" class="btn" style="background:#334155">Freeze</button>
            <button id="reverse" class="btn" style="background:#ef4444">Reverse</button>
            <button id="halfSpeed" class="btn">Half Speed</button>
            <button id="doubleSpeed" class="btn">2x Speed</button>
          </div>

          <div style="margin-top:12px">
            <label class="muted small">Visualization</label>
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="showFreq" class="btn" style="background:#334155">Freq</button>
              <button id="showWave" class="btn">Wave</button>
            </div>
          </div>
        </div>

        <footer>
          Tip: Use loop + stutter + delay to create rhythmic remixes. Save and export WAV when satisfied.
        </footer>
      </main>

    </div>
  </div>

<script>
// Advanced Audio Remixer - single-file
// Fixed: avoid connecting a node to itself (was causing IndexSizeError)

let audioCtx, sourceNode, buffer, analyser, dataArray, animationId;
let masterGain, panNode;
let delayNode, delayFeedback, delayWet;
let biquadFilter;
let flangerDelay, flangerOsc, flangerDepthGain;
let phaserNodes = [];
let gateGain, gateOsc, gateDepthGain;
let crusherNode;
let isPlaying = false;
let startAt = 0, pausedAt = 0;
let loopStart = 0, loopEnd = 0;
let loopBars = 1;
let bpm = 120;
let showWave = true;
let recorder;
let recordedChunks = [];

const fileInput = document.getElementById('file');
const loadDemo = document.getElementById('loadDemo');
const playBtn = document.getElementById('play');
const stopBtn = document.getElementById('stop');
const recordBtn = document.getElementById('record');
const exportWav = document.getElementById('exportWav');
const exportLoop = document.getElementById('exportLoop');
const waveCanvas = document.getElementById('wave');
const waveCtx = waveCanvas.getContext('2d');
const meterBar = document.getElementById('meterBar');

function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // master
    masterGain = audioCtx.createGain(); masterGain.gain.value = 1;
    panNode = audioCtx.createStereoPanner(); panNode.pan.value = 0;

    // analyser
    analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048;
    dataArray = new Uint8Array(analyser.fftSize);

    // delay
    delayNode = audioCtx.createDelay(5.0);
    delayNode.delayTime.value = 0.25;
    delayFeedback = audioCtx.createGain(); delayFeedback.gain.value = 0.35;
    delayWet = audioCtx.createGain(); delayWet.gain.value = 0.4;
    // feedback loop
    delayNode.connect(delayFeedback); delayFeedback.connect(delayNode);

    // filter
    biquadFilter = audioCtx.createBiquadFilter(); biquadFilter.type = 'lowpass'; biquadFilter.frequency.value = 1200; biquadFilter.Q.value = 1;

    // flanger
    flangerDelay = audioCtx.createDelay(); flangerDelay.delayTime.value = 0.003;
    flangerOsc = audioCtx.createOscillator();
    flangerDepthGain = audioCtx.createGain(); flangerDepthGain.gain.value = 0.003;
    flangerOsc.connect(flangerDepthGain); flangerDepthGain.connect(flangerDelay.delayTime);
    flangerOsc.start();

    // phaser (simple allpass chain) - create and connect chain once
    for(let i=0;i<4;i++){ const ap = audioCtx.createBiquadFilter(); ap.type='allpass'; ap.frequency.value = 1000*(i+1); phaserNodes.push(ap); }
    for(let i=0;i<phaserNodes.length-1;i++){ phaserNodes[i].connect(phaserNodes[i+1]); }

    // gate (tremolo)
    gateGain = audioCtx.createGain(); gateGain.gain.value = 1;
    gateOsc = audioCtx.createOscillator(); gateOsc.type='square'; gateOsc.frequency.value = 8; gateDepthGain = audioCtx.createGain(); gateDepthGain.gain.value = 1; gateOsc.connect(gateDepthGain); gateDepthGain.connect(gateGain.gain); gateOsc.start();

    // bitcrusher - simple script processor
    crusherNode = createBitCrusher(audioCtx,16,1);

    // connect master -> analyser -> destination
    masterGain.connect(panNode); panNode.connect(analyser); analyser.connect(audioCtx.destination);
    // connect delay wet to master
    delayWet.connect(masterGain);

    // also connect direct master path for convenience
    // (sources will be connected to masterGain as final node)
  }
}

function createBitCrusher(context, bits = 16, norm = 1){
  // Use ScriptProcessorNode fallback
  const bufferSize = 4096; const node = context.createScriptProcessor(bufferSize,1,1);
  node.bits = bits; node.norm = norm;
  node.onaudioprocess = function(e){
    const input = e.inputBuffer.getChannelData(0);
    const output = e.outputBuffer.getChannelData(0);
    const step = Math.pow(0.5, node.bits);
    for(let i=0;i<input.length;i++){
      output[i] = Math.round(input[i]/step)*step*node.norm;
    }
  }
  return node;
}

async function loadFile(file){
  ensureAudio();
  const arrayBuffer = await file.arrayBuffer();
  buffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
  loopStart = 0; loopEnd = buffer.duration;
  drawWaveFromBuffer(buffer);
}

function createSource(){
  if(!buffer) return null;
  ensureAudio();
  const src = audioCtx.createBufferSource(); src.buffer = buffer;
  src.playbackRate.value = parseFloat(document.getElementById('playbackRate').value);

  // Build chain by connecting nodes immediately. Avoid connecting a node to itself.
  let current = src;

  if(document.getElementById('enableCrush').checked){
    current.connect(crusherNode);
    current = crusherNode;
  }

  if(document.getElementById('enablePhaser').checked){
    // connect into the pre-built phaser chain
    current.connect(phaserNodes[0]);
    current = phaserNodes[phaserNodes.length-1];
  }

  if(document.getElementById('enableFlanger').checked){
    current.connect(flangerDelay);
    current = flangerDelay;
  }

  if(document.getElementById('enableFilter').checked){
    current.connect(biquadFilter);
    current = biquadFilter;
  }

  if(document.getElementById('enableGate').checked){
    current.connect(gateGain);
    current = gateGain;
  }

  // always send a tap to delay (wet) via delayNode (as a send)
  try{
    current.connect(delayNode);
  }catch(e){/*ignore if already connected*/}

  // connect delay path to wet (already done in ensureAudio)
  // finally connect to master gain
  current.connect(masterGain);

  return src;
}

function play(){
  if(!buffer) return;
  ensureAudio();
  if(isPlaying) return;
  sourceNode = createSource();
  if(!sourceNode) return;

  const offset = pausedAt || 0;
  sourceNode.loop = true;
  // compute loop end in seconds based on BPM and bars
  const bars = parseInt(document.getElementById('loopBars').value) || 1;
  const beatsPerBar = 4; // assume 4/4
  const loopSeconds = (60 / bpm) * (beatsPerBar * bars);
  sourceNode.loopStart = loopStart;
  sourceNode.loopEnd = loopStart + Math.min(loopSeconds, buffer.duration - loopStart);

  // start source directly (connections were already made in createSource)
  sourceNode.start(0, offset);
  startAt = audioCtx.currentTime - offset;
  isPlaying = true;
  animate();
}

function stop(){
  if(!isPlaying) return;
  try{ sourceNode.stop(); }catch(e){}
  pausedAt = 0;
  isPlaying = false;
  cancelAnimationFrame(animationId);
}

function createAnalyzerDraw(){
  const DPR = window.devicePixelRatio || 1;
  // set actual canvas pixel size
  waveCanvas.width = Math.floor(waveCanvas.clientWidth * DPR);
  waveCanvas.height = Math.floor(waveCanvas.clientHeight * DPR);
  // reset transform and scale once for drawing at device pixel ratio
  waveCtx.setTransform(1,0,0,1,0,0);
  waveCtx.scale(DPR, DPR);
}

function draw(){
  // NOTE: do NOT call createAnalyzerDraw every frame (it caused repeated scaling and heavy work).
  if(showWave){
    analyser.getByteTimeDomainData(dataArray);
    waveCtx.clearRect(0,0,waveCanvas.clientWidth,waveCanvas.clientHeight);
    waveCtx.lineWidth = 2; waveCtx.beginPath();
    const slice = waveCanvas.clientWidth / dataArray.length;
    for(let i=0;i<dataArray.length;i++){
      const v = dataArray[i] / 128.0; const y = v * waveCanvas.clientHeight/2;
      if(i===0) waveCtx.moveTo(0,y); else waveCtx.lineTo(i*slice,y);
    }
    waveCtx.strokeStyle = '#7c3aed'; waveCtx.stroke();
  } else {
    // show frequency
    analyser.getByteFrequencyData(dataArray);
    waveCtx.clearRect(0,0,waveCanvas.clientWidth,waveCanvas.clientHeight);
    const barWidth = waveCanvas.clientWidth / dataArray.length;
    for(let i=0;i<dataArray.length;i++){
      const v = dataArray[i]/255; const h = v * waveCanvas.clientHeight;
      waveCtx.fillStyle = '#7c3aed'; waveCtx.fillRect(i*barWidth, waveCanvas.clientHeight - h, barWidth, h);
    }
  }

  // meter
  analyser.getByteFrequencyData(dataArray);
  let sum = 0; for(let i=0;i<dataArray.length;i++) sum += dataArray[i];
  const rms = sum / dataArray.length / 255;
  meterBar.style.width = Math.min(100, Math.round(rms*100)) + '%';

  animationId = requestAnimationFrame(draw);
}

function animate(){ animationId = requestAnimationFrame(draw); }

function drawWaveFromBuffer(buf){
  // simple waveform rendering (improved)
  const ch = buf.getChannelData(0);
  const width = waveCanvas.clientWidth; const height = waveCanvas.clientHeight;
  const step = Math.max(1, Math.floor(ch.length / width));
  const amp = height/2;
  waveCtx.clearRect(0,0,width,height);
  waveCtx.beginPath();
  for(let i=0, x=0; i<ch.length; i+=step, x++){
    const v = ch[i]; const y = amp + v * amp;
    if(x===0) waveCtx.moveTo(x,y); else waveCtx.lineTo(x,y);
  }
  waveCtx.strokeStyle = '#7c3aed'; waveCtx.lineWidth = 1.5; waveCtx.stroke();
}

// Wiring UI controls
fileInput.addEventListener('change', async(e)=>{ if(e.target.files.length) await loadFile(e.target.files[0]); });

loadDemo.addEventListener('click', async ()=>{
  ensureAudio();
  const sr = audioCtx.sampleRate; const len = sr * 6; const b = audioCtx.createBuffer(1, len, sr);
  const d = b.getChannelData(0);
  for(let i=0;i<len;i++){
    d[i] = Math.sin(i * 440 * 2 * Math.PI / sr) * 0.1 * (Math.random()*0.4+0.6);
    if(i % Math.round(sr*0.25) < 200) d[i] *= 0.5;
  }
  buffer = b; loopStart = 0; loopEnd = buffer.duration; drawWaveFromBuffer(buffer);
});

playBtn.addEventListener('click', ()=>{ if(!isPlaying) play(); else { pausedAt = audioCtx.currentTime - startAt; try{ sourceNode.stop(); }catch(e){} isPlaying=false; }});
stopBtn.addEventListener('click', ()=>{ stop(); });

recordBtn.addEventListener('click', ()=>{
  if(!recorder){
    const dest = audioCtx.createMediaStreamDestination(); masterGain.connect(dest);
    recorder = new MediaRecorder(dest.stream); recordedChunks = [];
    recorder.ondataavailable = e=>{ if(e.data.size) recordedChunks.push(e.data); };
    recorder.onstop = ()=>{
      const blob = new Blob(recordedChunks,{type:'audio/wav'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='Remix Audio by_HIRU_OFFICIAL.wav'; a.click();
    }
    recorder.start(); recordBtn.textContent='Stop Rec'; recordBtn.style.background='#ef4444';
  } else {
    recorder.stop(); recorder=null; recordBtn.textContent='Record'; recordBtn.style.background='';
  }
});

// effect controls: delay
const delayTime = document.getElementById('delayTime'); const delayFB = document.getElementById('delayFB'); const delayWetEl = document.getElementById('delayWet');
delayTime.addEventListener('input', ()=>{ if(delayNode) delayNode.delayTime.value = parseFloat(delayTime.value); document.getElementById('delayTimeVal').textContent = parseFloat(delayTime.value).toFixed(2)+'s'; });
delayFB.addEventListener('input', ()=>{ if(delayFeedback) delayFeedback.gain.value = parseFloat(delayFB.value); document.getElementById('delayFBVal').textContent = parseFloat(delayFB.value).toFixed(2); });
delayWetEl.addEventListener('input', ()=>{ if(delayWet) delayWet.gain.value = parseFloat(delayWetEl.value); document.getElementById('delayWetVal').textContent = parseFloat(delayWetEl.value).toFixed(2); });

// filter
const filterFreq = document.getElementById('filterFreq'); const filterQ = document.getElementById('filterQ'); const filterType = document.getElementById('filterType');
filterFreq.addEventListener('input', ()=>{ if(biquadFilter) biquadFilter.frequency.value = parseFloat(filterFreq.value); document.getElementById('filterFreqVal').textContent = Math.round(parseFloat(filterFreq.value))+'Hz'; });
filterQ.addEventListener('input', ()=>{ if(biquadFilter) biquadFilter.Q.value = parseFloat(filterQ.value); document.getElementById('filterQVal').textContent = parseFloat(filterQ.value).toFixed(1); });
filterType.addEventListener('change', ()=>{ if(biquadFilter) biquadFilter.type = filterType.value; });

// flanger
const flangerRate = document.getElementById('flangerRate'); const flangerDepth = document.getElementById('flangerDepth');
flangerRate.addEventListener('input', ()=>{ if(flangerOsc) flangerOsc.frequency.value = parseFloat(flangerRate.value); document.getElementById('flangerRateVal').textContent = parseFloat(flangerRate.value).toFixed(2)+'Hz'; });
flangerDepth.addEventListener('input', ()=>{ if(flangerDepthGain) flangerDepthGain.gain.value = parseFloat(flangerDepth.value); document.getElementById('flangerDepthVal').textContent = parseFloat(flangerDepth.value).toFixed(4)+'s'; });

// phaser
const phaserRate = document.getElementById('phaserRate'); const phaserDepth = document.getElementById('phaserDepth');
phaserRate.addEventListener('input', ()=>{ document.getElementById('phaserRateVal').textContent = phaserRate.value+'Hz'; });
phaserDepth.addEventListener('input', ()=>{ document.getElementById('phaserDepthVal').textContent = phaserDepth.value; });

// gate
const gateRate = document.getElementById('gateRate'); const gateDepth = document.getElementById('gateDepth');
gateRate.addEventListener('input', ()=>{ if(gateOsc) gateOsc.frequency.value = parseFloat(gateRate.value); document.getElementById('gateRateVal').textContent = parseFloat(gateRate.value).toFixed(1)+'Hz'; });
gateDepth.addEventListener('input', ()=>{ if(gateDepthGain) gateDepthGain.gain.value = parseFloat(gateDepth.value); document.getElementById('gateDepthVal').textContent = parseFloat(gateDepth.value); });

// bitcrusher
const bits = document.getElementById('bits'); const norm = document.getElementById('norm');
bits.addEventListener('input', ()=>{ if(crusherNode) crusherNode.bits = parseInt(bits.value); document.getElementById('bitsVal').textContent = bits.value; });
norm.addEventListener('input', ()=>{ if(crusherNode) crusherNode.norm = parseFloat(norm.value); document.getElementById('normVal').textContent = norm.value; });

// master controls
const volume = document.getElementById('volume'); const pan = document.getElementById('pan');
volume.addEventListener('input', ()=>{ if(masterGain) masterGain.gain.value = parseFloat(volume.value); document.getElementById('volVal').textContent = parseFloat(volume.value).toFixed(2); });
pan.addEventListener('input', ()=>{ if(panNode) panNode.pan.value = parseFloat(pan.value); document.getElementById('panVal').textContent = parseFloat(pan.value).toFixed(2); });

const playbackRate = document.getElementById('playbackRate'); playbackRate.addEventListener('input', ()=>{ document.getElementById('rateVal').textContent = parseFloat(playbackRate.value).toFixed(2); if(sourceNode) try{ sourceNode.playbackRate.value = parseFloat(playbackRate.value); }catch(e){} });

const bpmEl = document.getElementById('bpm'); bpmEl.addEventListener('input', ()=>{ bpm = parseInt(bpmEl.value); document.getElementById('bpmVal').textContent = bpm; });

// quick presets
document.querySelectorAll('.chip').forEach(c => c.addEventListener('click', ()=>{
  const p = c.dataset.preset;
  if(p==='deep'){
    filterFreq.value=800; filterQ.value=1.2; delayTime.value=0.45; delayFB.value=0.6; delayWet.value=0.45; bits.value=12; norm.value=0.9;
  } else if(p==='vocal'){
    filterFreq.value=3000; filterQ.value=1.5; delayTime.value=0.18; delayFB.value=0.25; delayWet.value=0.28; bits.value=16; norm.value=1;
  } else if(p==='dub'){
    filterFreq.value=2000; delayTime.value=0.38; delayFB.value=0.8; delayWet.value=0.6; bits.value=10; norm.value=0.8;
  } else if(p==='lofi'){
    filterFreq.value=1500; delayTime.value=0.12; delayFB.value=0.2; bits.value=8; norm.value=0.6; }
  // update UI triggers
  filterFreq.dispatchEvent(new Event('input')); filterQ.dispatchEvent(new Event('input')); delayTime.dispatchEvent(new Event('input')); delayFB.dispatchEvent(new Event('input')); delayWetEl.dispatchEvent(new Event('input')); bits.dispatchEvent(new Event('input')); norm.dispatchEvent(new Event('input'));
}));

// stutter / roll
document.getElementById('stutter').addEventListener('click', ()=>{
  if(!buffer) return;
  const sec = 0.125;
  ensureAudio();
  const now = audioCtx.currentTime;
  const s = audioCtx.createBufferSource(); s.buffer = buffer; s.playbackRate.value = parseFloat(playbackRate.value);
  s.connect(masterGain);
  s.start(now, 0, sec);
});

document.getElementById('freeze').addEventListener('click', ()=>{
  if(!buffer) return;
  ensureAudio();
  const s = audioCtx.createBufferSource(); s.buffer = buffer; s.loop = true; s.loopStart = 0; s.loopEnd = Math.min(1, buffer.duration);
  s.connect(masterGain); s.start(); setTimeout(()=>{ try{s.stop();}catch(e){} }, 3000);
});

document.getElementById('reverse').addEventListener('click', ()=>{
  if(!buffer) return;
  ensureAudio();
  const rb = audioCtx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
  for(let ch=0; ch<buffer.numberOfChannels; ch++){
    const src = buffer.getChannelData(ch); const dst = rb.getChannelData(ch);
    for(let i=0;i<src.length;i++) dst[i] = src[src.length - i - 1];
  }
  const s = audioCtx.createBufferSource(); s.buffer = rb; s.connect(masterGain); s.start(); setTimeout(()=>{ try{s.stop();}catch(e){} }, Math.min(5, rb.duration)*1000);
});

document.getElementById('halfSpeed').addEventListener('click', ()=>{ playbackRate.value = parseFloat(playbackRate.value) * 0.5; playbackRate.dispatchEvent(new Event('input')); if(sourceNode) try{ sourceNode.playbackRate.value = playbackRate.value; }catch(e){} });
document.getElementById('doubleSpeed').addEventListener('click', ()=>{ playbackRate.value = Math.min(2, parseFloat(playbackRate.value) * 2); playbackRate.dispatchEvent(new Event('input')); if(sourceNode) try{ sourceNode.playbackRate.value = playbackRate.value; }catch(e){} });

// show freq / wave
document.getElementById('showFreq').addEventListener('click', ()=>{ showWave=false; });
document.getElementById('showWave').addEventListener('click', ()=>{ showWave=true; });

// export
exportWav.addEventListener('click', ()=>{
  if(!buffer){ alert('Load audio first'); return; }
  const offlineCtx = new OfflineAudioContext(2, Math.floor(buffer.duration * buffer.sampleRate), buffer.sampleRate);
  const src = offlineCtx.createBufferSource(); src.buffer = buffer;
  const offlineGain = offlineCtx.createGain(); offlineGain.gain.value = parseFloat(volume.value);
  src.connect(offlineGain);
  offlineGain.connect(offlineCtx.destination);
  src.start();
  offlineCtx.startRendering().then(rendered => {
    const wav = audioBufferToWav(rendered);
    const blob = new Blob([new DataView(wav)], {type: 'audio/wav'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='mixdown.wav'; a.click();
  });
});

exportLoop.addEventListener('click', ()=>{
  if(!buffer) return;
  const bars = parseInt(document.getElementById('loopBars').value)||1; const beats=4; const loopSec = (60/bpm)*(beats*bars);
  const len = Math.floor(loopSec * buffer.sampleRate);
  const newBuf = (audioCtx) ? audioCtx.createBuffer(buffer.numberOfChannels, len, buffer.sampleRate) : null;
  if(!newBuf){ alert('Audio context not initialized'); return; }
  for(let ch=0; ch<buffer.numberOfChannels; ch++){
    const src = buffer.getChannelData(ch); const dst = newBuf.getChannelData(ch);
    for(let i=0;i<len;i++) dst[i] = src[i % src.length];
  }
  const wav = audioBufferToWav(newBuf);
  const blob = new Blob([new DataView(wav)], {type: 'audio/wav'});
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='loop.wav'; a.click();
});

// util: convert AudioBuffer to WAV (16-bit PCM)
function audioBufferToWav(buffer, opt) {
  opt = opt || {}
  var numChannels = buffer.numberOfChannels
  var sampleRate = buffer.sampleRate
  var format = opt.float32 ? 3 : 1
  var bitDepth = format === 3 ? 32 : 16

  var result
  if (numChannels === 2) {
    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))
  } else {
    result = buffer.getChannelData(0)
  }

  return encodeWAV(result, format, sampleRate, numChannels, bitDepth)
}

function interleave(inputL, inputR){
  var length = inputL.length + inputR.length
  var result = new Float32Array(length)
  var index = 0
  var inputIndex = 0
  while (index < length) {
    result[index++] = inputL[inputIndex]
    result[index++] = inputR[inputIndex]
    inputIndex++
  }
  return result
}

function encodeWAV(samples, format, sampleRate, numChannels, bitDepth){
  var bytesPerSample = bitDepth / 8
  var blockAlign = numChannels * bytesPerSample

  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)
  var view = new DataView(buffer)

  /* RIFF identifier */ writeString(view, 0, 'RIFF')
  /* file length */ view.setUint32(4, 36 + samples.length * bytesPerSample, true)
  /* RIFF type */ writeString(view, 8, 'WAVE')
  /* format chunk identifier */ writeString(view, 12, 'fmt ')
  /* format chunk length */ view.setUint32(16, 16, true)
  /* sample format (raw) */ view.setUint16(20, format, true)
  /* channel count */ view.setUint16(22, numChannels, true)
  /* sample rate */ view.setUint32(24, sampleRate, true)
  /* byte rate (sample rate * block align) */ view.setUint32(28, sampleRate * blockAlign, true)
  /* block align (channel count * bytes per sample) */ view.setUint16(32, blockAlign, true)
  /* bits per sample */ view.setUint16(34, bitDepth, true)
  /* data chunk identifier */ writeString(view, 36, 'data')
  /* data chunk length */ view.setUint32(40, samples.length * bytesPerSample, true)

  if (format === 1) { // PCM
    floatTo16BitPCM(view, 44, samples)
  } else {
    writeFloat32(view, 44, samples)
  }

  return buffer
}

function floatTo16BitPCM(output, offset, input){
  for (var i = 0; i < input.length; i++, offset += 2) {
    var s = Math.max(-1, Math.min(1, input[i]))
    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)
  }
}

function writeFloat32(output, offset, input){
  for (var i = 0; i < input.length; i++, offset += 4) {
    output.setFloat32(offset, input[i], true)
  }
}

function writeString(view, offset, string){
  for (var i = 0; i < string.length; i++){
    view.setUint8(offset + i, string.charCodeAt(i))
  }
}

// init visual canvas size
window.addEventListener('resize', ()=>{ createAnalyzerDraw(); });
createAnalyzerDraw();

</script>
</body>
</html>

